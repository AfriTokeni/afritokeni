use crate::models::*;
use crate::DataCanisterState;
use ic_cdk::api::time;
use sha2::Sha256;
use hmac::{Hmac, Mac};

type HmacSha256 = Hmac<Sha256>;

const MAX_PIN_ATTEMPTS: u32 = 5;
const PIN_LOCKOUT_DURATION: u64 = 30 * 60; // 30 minutes in seconds

/// Setup PIN with provided salt (salt generated by caller - USSD/Web canister)
/// This keeps the data canister pure - no random number generation needed
pub fn setup_pin_with_salt(
    state: &mut DataCanisterState,
    user_id: String,
    pin: &str,
    salt_hex: String,
) -> Result<(), String> {
    // Validate PIN format (4-6 digits)
    if !pin.chars().all(|c| c.is_ascii_digit()) || !(4..=6).contains(&pin.len()) {
        return Err("PIN must be 4-6 digits".to_string());
    }

    // Check if user exists
    if !state.users.contains_key(&user_id) {
        return Err("User not found".to_string());
    }

    let now = time() / 1_000_000_000;

    // Hash PIN with salt
    let pin_hash = hash_pin(pin, &salt_hex)?;

    // Create PIN record
    let user_pin = UserPin {
        user_id: user_id.clone(),
        pin_hash,
        salt: salt_hex,
        failed_attempts: 0,
        locked_until: None,
        created_at: now,
        updated_at: now,
    };

    // Store PIN
    state.user_pins.insert(user_id.clone(), user_pin);

    // Log audit entry
    let audit_entry = AuditEntry {
        timestamp: now,
        action: "pin_setup".to_string(),
        user_id: Some(user_id),
        details: "PIN setup completed".to_string(),
    };
    state.log_audit(audit_entry);

    Ok(())
}

/// Verify PIN and handle lockout logic
pub fn verify_pin(
    state: &mut DataCanisterState,
    user_id: String,
    pin: &str,
) -> Result<bool, String> {
    let now = time() / 1_000_000_000;

    let mut user_pin = state.user_pins.get(&user_id)
        .ok_or("PIN not set for user")?
        .clone();

    // Check if PIN is locked
    if let Some(locked_until) = user_pin.locked_until {
        if now < locked_until {
            let remaining = locked_until - now;
            return Err(format!("PIN locked. Try again in {} minutes", remaining / 60));
        } else {
            // Lockout expired, reset attempts
            user_pin.failed_attempts = 0;
            user_pin.locked_until = None;
        }
    }

    // Hash provided PIN with stored salt
    let expected_hash = hash_pin(pin, &user_pin.salt)?;

    if expected_hash == user_pin.pin_hash {
        // PIN correct - reset attempts
        user_pin.failed_attempts = 0;
        user_pin.locked_until = None;
        user_pin.updated_at = now;

        state.user_pins.insert(user_id.clone(), user_pin);

        // Log audit entry
        let audit_entry = AuditEntry {
            timestamp: now,
            action: "pin_verified".to_string(),
            user_id: Some(user_id),
            details: "PIN verification successful".to_string(),
        };
        state.log_audit(audit_entry);

        Ok(true)
    } else {
        // PIN incorrect - increment attempts
        user_pin.failed_attempts += 1;
        user_pin.updated_at = now;

        // Check if should lock
        if user_pin.failed_attempts >= MAX_PIN_ATTEMPTS {
            user_pin.locked_until = Some(now + PIN_LOCKOUT_DURATION);
        }

        let failed_attempts = user_pin.failed_attempts;
        state.user_pins.insert(user_id.clone(), user_pin);

        // Log audit entry
        let audit_entry = AuditEntry {
            timestamp: now,
            action: "pin_failed".to_string(),
            user_id: Some(user_id),
            details: format!("PIN verification failed. Attempts: {}", failed_attempts),
        };
        state.log_audit(audit_entry);

        Ok(false)
    }
}

/// Reset PIN attempts (admin function)
pub fn reset_attempts(
    state: &mut DataCanisterState,
    user_id: String,
) -> Result<(), String> {
    let now = time() / 1_000_000_000;

    let user_pin = state.user_pins.get_mut(&user_id)
        .ok_or("PIN not set for user")?;

    user_pin.failed_attempts = 0;
    user_pin.locked_until = None;
    user_pin.updated_at = now;

    // Log audit entry
    let audit_entry = AuditEntry {
        timestamp: now,
        action: "pin_attempts_reset".to_string(),
        user_id: Some(user_id),
        details: "PIN attempts reset".to_string(),
    };
    state.log_audit(audit_entry);

    Ok(())
}

/// Change PIN (requires old PIN verification first)
pub fn change_pin(
    state: &mut DataCanisterState,
    user_id: String,
    old_pin: &str,
    new_pin: &str,
    new_salt: String,
) -> Result<(), String> {
    // Verify old PIN first
    if !verify_pin(state, user_id.clone(), old_pin)? {
        return Err("Current PIN is incorrect".to_string());
    }

    // Setup new PIN
    setup_pin_with_salt(state, user_id, new_pin, new_salt)
}

/// Hash PIN using HMAC-SHA256 with salt
fn hash_pin(pin: &str, salt: &str) -> Result<String, String> {
    let salt_bytes = hex::decode(salt)
        .map_err(|_| "Invalid salt format")?;

    let mut mac = HmacSha256::new_from_slice(&salt_bytes)
        .map_err(|_| "Failed to create HMAC")?;
    mac.update(pin.as_bytes());
    let result = mac.finalize();
    
    Ok(hex::encode(result.into_bytes()))
}

/// Check if PIN is locked
pub fn is_pin_locked(
    state: &DataCanisterState,
    user_id: String,
) -> Result<bool, String> {
    let now = time() / 1_000_000_000;

    let user_pin = state.user_pins.get(&user_id)
        .ok_or("PIN not set for user")?;

    if let Some(locked_until) = user_pin.locked_until {
        Ok(now < locked_until)
    } else {
        Ok(false)
    }
}

/// Get remaining lockout time in seconds
pub fn get_remaining_lockout_time(
    state: &DataCanisterState,
    user_id: String,
) -> Result<u64, String> {
    let now = time() / 1_000_000_000;

    let user_pin = state.user_pins.get(&user_id)
        .ok_or("PIN not set for user")?;

    if let Some(locked_until) = user_pin.locked_until {
        if now < locked_until {
            Ok(locked_until - now)
        } else {
            Ok(0)
        }
    } else {
        Ok(0)
    }
}

/// Get failed attempt count
pub fn get_failed_attempts(
    state: &DataCanisterState,
    user_id: String,
) -> Result<u32, String> {
    let user_pin = state.user_pins.get(&user_id)
        .ok_or("PIN not set for user")?;

    Ok(user_pin.failed_attempts)
}
