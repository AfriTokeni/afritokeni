// ============================================================================
// PIN SECURITY MODULE - DUAL SYSTEM ARCHITECTURE
// ============================================================================
//
// SECURITY NOTICE: This module supports TWO PIN hashing systems:
//
// 1. HMAC-SHA256 (DEPRECATED - LEGACY SUPPORT ONLY)
//    - Fast but NOT suitable for password hashing
//    - Vulnerable to offline brute-force attacks if hash leaks
//    - Only 10,000 - 1,000,000 possible PINs (4-6 digits)
//    - Attack time: Seconds to minutes on modern hardware
//    - STATUS: DEPRECATED - Will be removed in future version
//    - MIGRATION PATH: Use Argon2 system instead
//
// 2. Argon2id (RECOMMENDED - MODERN SYSTEM)
//    - Memory-hard algorithm designed for password hashing
//    - Resistant to GPU/ASIC attacks
//    - Hashing performed in user_canister (business logic layer)
//    - data_canister provides pure storage only
//    - STATUS: ACTIVE - Use for all new PIN setups
//
// MIGRATION STRATEGY:
// - New users: Use Argon2 system (store_pin_hash/get_pin_hash)
// - Existing users: Migrate on next PIN change
// - Gradual deprecation: Remove HMAC after 90% migration
// - Timeline: Q1 2026 target for full Argon2 migration
//
// ============================================================================

use crate::models::*;
use crate::DataCanisterState;
use ic_cdk::api::time;
use sha2::Sha256;
use hmac::{Hmac, Mac};
use shared_types::audit;

type HmacSha256 = Hmac<Sha256>;

const MAX_PIN_ATTEMPTS: u32 = 3;
const PIN_LOCKOUT_DURATION: u64 = 30 * 60; // 30 minutes in seconds

// ============================================================================
// LEGACY HMAC-SHA256 SYSTEM (DEPRECATED)
// ============================================================================
// DEPRECATION NOTICE: These functions are maintained for backward compatibility
// only. All new code should use the Argon2 system below.

/// Setup PIN with provided salt (salt generated by caller - USSD/Web canister)
/// This keeps the data canister pure - no random number generation needed
///
/// # DEPRECATED
/// This function uses HMAC-SHA256 which is NOT suitable for password hashing.
/// HMAC-SHA256 is fast and vulnerable to offline brute-force attacks.
/// With only 10,000-1,000,000 possible PINs (4-6 digits), an attacker can
/// brute-force all combinations in seconds if the hash leaks.
///
/// **Migration Path**: Use `store_pin_hash` with Argon2id hashing instead.
/// See the Argon2 system documentation below for proper usage.
///
/// **Timeline**: This function will be removed in v2.0.0 (Q1 2026).
#[deprecated(
    since = "0.2.0",
    note = "HMAC-SHA256 is not suitable for password hashing. Use store_pin_hash with Argon2id instead. Will be removed in v2.0.0."
)]
pub fn setup_pin_with_salt(
    state: &mut DataCanisterState,
    user_id: String,
    pin: &str,
    salt_hex: String,
) -> Result<(), String> {
    // Validate PIN format (4-6 digits)
    if !pin.chars().all(|c| c.is_ascii_digit()) || !(4..=6).contains(&pin.len()) {
        return Err("PIN must be 4-6 digits".to_string());
    }

    // Check if user exists
    if !state.users.contains_key(&user_id) {
        return Err("User not found".to_string());
    }

    let now = time() / 1_000_000_000;

    // Hash PIN with salt
    let pin_hash = hash_pin(pin, &salt_hex)?;

    // Create PIN record
    let user_pin = UserPin {
        user_id: user_id.clone(),
        pin_hash,
        salt: salt_hex,
        failed_attempts: 0,
        locked_until: None,
        created_at: now,
        updated_at: now,
    };

    // Store PIN
    state.user_pins.insert(user_id.clone(), user_pin);

    // Log audit using shared library
    audit::log_success(
        "pin_setup",
        Some(user_id),
        "PIN setup completed".to_string()
    );

    Ok(())
}

/// Verify PIN and handle lockout logic
///
/// # DEPRECATED
/// This function uses HMAC-SHA256 which is NOT suitable for password hashing.
/// HMAC-SHA256 is fast and vulnerable to offline brute-force attacks.
/// With only 10,000-1,000,000 possible PINs (4-6 digits), an attacker can
/// brute-force all combinations in seconds if the hash leaks.
///
/// **Migration Path**: Use the Argon2 verification flow:
/// 1. Call `get_pin_hash` to retrieve the stored Argon2 hash
/// 2. Verify PIN in user_canister using `argon2::verify_password`
/// 3. Call `reset_attempts` on success or `increment_failed_attempts` on failure
///
/// **Timeline**: This function will be removed in v2.0.0 (Q1 2026).
#[deprecated(
    since = "0.2.0",
    note = "HMAC-SHA256 is not suitable for password hashing. Use get_pin_hash + Argon2 verification instead. Will be removed in v2.0.0."
)]
pub fn verify_pin(
    state: &mut DataCanisterState,
    user_id: String,
    pin: &str,
) -> Result<bool, String> {
    let now = time() / 1_000_000_000;

    let mut user_pin = state.user_pins.get(&user_id)
        .ok_or("PIN not set for user")?
        .clone();

    // Check if PIN is locked
    if let Some(locked_until) = user_pin.locked_until {
        if now < locked_until {
            let remaining = locked_until - now;
            return Err(format!("PIN locked. Try again in {} minutes", remaining / 60));
        } else {
            // Lockout expired, reset attempts
            user_pin.failed_attempts = 0;
            user_pin.locked_until = None;
        }
    }

    // Hash provided PIN with stored salt
    let expected_hash = hash_pin(pin, &user_pin.salt)?;

    if expected_hash == user_pin.pin_hash {
        // PIN correct - reset attempts
        user_pin.failed_attempts = 0;
        user_pin.locked_until = None;
        user_pin.updated_at = now;

        state.user_pins.insert(user_id.clone(), user_pin);

        // Log audit using shared library
        audit::log_success(
            "pin_verified",
            Some(user_id),
            "PIN verification successful".to_string()
        );

        Ok(true)
    } else {
        // PIN incorrect - increment attempts
        user_pin.failed_attempts += 1;
        user_pin.updated_at = now;

        // Check if should lock
        if user_pin.failed_attempts >= MAX_PIN_ATTEMPTS {
            user_pin.locked_until = Some(now + PIN_LOCKOUT_DURATION);
        }

        let failed_attempts = user_pin.failed_attempts;
        state.user_pins.insert(user_id.clone(), user_pin);

        // Log audit using shared library
        audit::log_failure(
            "pin_failed",
            Some(user_id),
            format!("PIN verification failed. Attempts: {}", failed_attempts)
        );

        Ok(false)
    }
}

/// Reset PIN attempts (admin function)
pub fn reset_attempts(
    state: &mut DataCanisterState,
    user_id: String,
) -> Result<(), String> {
    let now = time() / 1_000_000_000;

    let user_pin = state.user_pins.get_mut(&user_id)
        .ok_or("PIN not set for user")?;

    user_pin.failed_attempts = 0;
    user_pin.locked_until = None;
    user_pin.updated_at = now;

    // Log audit using shared library
    audit::log_success(
        "pin_attempts_reset",
        Some(user_id),
        "PIN attempts reset".to_string()
    );

    Ok(())
}

/// Change PIN (requires old PIN verification first)
///
/// # DEPRECATED
/// This function uses the deprecated HMAC-SHA256 verification system.
///
/// **Migration Path**: Implement PIN change flow in user_canister:
/// 1. Verify old PIN using Argon2 verification
/// 2. Hash new PIN using Argon2
/// 3. Call `store_pin_hash` to update the PIN
///
/// **Timeline**: This function will be removed in v2.0.0 (Q1 2026).
#[deprecated(
    since = "0.2.0",
    note = "Uses deprecated HMAC-SHA256 system. Implement PIN change in user_canister with Argon2. Will be removed in v2.0.0."
)]
pub fn change_pin(
    state: &mut DataCanisterState,
    user_id: String,
    old_pin: &str,
    new_pin: &str,
    new_salt: String,
) -> Result<(), String> {
    // Verify old PIN first
    #[allow(deprecated)]
    if !verify_pin(state, user_id.clone(), old_pin)? {
        return Err("Current PIN is incorrect".to_string());
    }

    // Setup new PIN
    #[allow(deprecated)]
    setup_pin_with_salt(state, user_id, new_pin, new_salt)
}

/// Hash PIN using HMAC-SHA256 with salt
fn hash_pin(pin: &str, salt: &str) -> Result<String, String> {
    let salt_bytes = hex::decode(salt)
        .map_err(|_| "Invalid salt format")?;

    let mut mac = HmacSha256::new_from_slice(&salt_bytes)
        .map_err(|_| "Failed to create HMAC")?;
    mac.update(pin.as_bytes());
    let result = mac.finalize();
    
    Ok(hex::encode(result.into_bytes()))
}

/// Check if PIN is locked
pub fn is_pin_locked(
    state: &DataCanisterState,
    user_id: String,
) -> Result<bool, String> {
    let now = time() / 1_000_000_000;

    let user_pin = state.user_pins.get(&user_id)
        .ok_or("PIN not set for user")?;

    if let Some(locked_until) = user_pin.locked_until {
        Ok(now < locked_until)
    } else {
        Ok(false)
    }
}

/// Get remaining lockout time in seconds
pub fn get_remaining_lockout_time(
    state: &DataCanisterState,
    user_id: String,
) -> Result<u64, String> {
    let now = time() / 1_000_000_000;

    let user_pin = state.user_pins.get(&user_id)
        .ok_or("PIN not set for user")?;

    if let Some(locked_until) = user_pin.locked_until {
        if now < locked_until {
            Ok(locked_until - now)
        } else {
            Ok(0)
        }
    } else {
        Ok(0)
    }
}

/// Get failed attempt count
pub fn get_failed_attempts(
    state: &DataCanisterState,
    user_id: String,
) -> Result<u32, String> {
    let user_pin = state.user_pins.get(&user_id)
        .ok_or("PIN not set for user")?;

    Ok(user_pin.failed_attempts)
}

// ============================================================================
// MODERN ARGON2 SYSTEM (RECOMMENDED)
// ============================================================================
//
// ARCHITECTURE:
// 1. PIN hashing happens in user_canister using Argon2id algorithm
// 2. data_canister provides pure storage (no hashing logic)
// 3. PIN verification happens in user_canister using argon2::verify_hash
// 4. Failed attempt tracking still managed by data_canister
//
// SECURITY BENEFITS:
// - Memory-hard algorithm (resistant to hardware attacks)
// - Configurable cost parameters (time, memory, parallelism)
// - Salt embedded in hash string (no separate salt storage)
// - Industry-standard password hashing (OWASP recommended)
//
// USAGE PATTERN:
// ```rust
// // In user_canister (business logic):
// use argon2::{Argon2, PasswordHasher};
// let salt = SaltString::generate(&mut OsRng);
// let argon2 = Argon2::default();
// let pin_hash = argon2.hash_password(pin.as_bytes(), &salt)?.to_string();
//
// // Store in data_canister:
// data_canister.store_pin_hash(user_id, pin_hash).await?;
//
// // Verify PIN in user_canister:
// let stored_hash = data_canister.get_pin_hash(user_id).await?;
// let parsed_hash = PasswordHash::new(&stored_hash)?;
// if argon2.verify_password(pin.as_bytes(), &parsed_hash).is_ok() {
//     // PIN correct - reset failed attempts
//     data_canister.reset_pin_attempts(user_id).await?;
// } else {
//     // PIN incorrect - increment failed attempts
//     data_canister.increment_failed_attempts(user_id).await?;
// }
// ```
//
// ============================================================================

/// Store PIN hash (Argon2 hash from user_canister)
/// This is pure storage - no hashing logic here
pub fn store_pin_hash(
    state: &mut DataCanisterState,
    user_id: String,
    pin_hash: String,
) -> Result<(), String> {
    let now = time() / 1_000_000_000;
    
    // Check if user exists
    if !state.users.contains_key(&user_id) {
        return Err("User not found".to_string());
    }
    
    // Create or update PIN record
    let user_pin = UserPin {
        user_id: user_id.clone(),
        pin_hash,
        salt: String::new(), // Not used for Argon2 (salt is in the hash)
        failed_attempts: 0,
        locked_until: None,
        created_at: now,
        updated_at: now,
    };
    
    state.user_pins.insert(user_id.clone(), user_pin);
    
    // Log audit using shared library
    audit::log_success(
        "pin_hash_stored",
        Some(user_id),
        "PIN hash stored (Argon2)".to_string()
    );
    
    Ok(())
}

/// Get PIN hash for verification
pub fn get_pin_hash(
    state: &DataCanisterState,
    user_id: String,
) -> Result<String, String> {
    let user_pin = state.user_pins.get(&user_id)
        .ok_or_else(|| format!("PIN not set for user: {}", user_id))?;
    
    Ok(user_pin.pin_hash.clone())
}

/// Increment failed PIN attempts and handle lockout
pub fn increment_failed_attempts(
    state: &mut DataCanisterState,
    user_id: String,
) -> Result<(), String> {
    let now = time() / 1_000_000_000;
    
    let mut user_pin = state.user_pins.get(&user_id)
        .ok_or_else(|| format!("PIN not set for user: {}", user_id))?
        .clone();
    
    user_pin.failed_attempts += 1;
    user_pin.updated_at = now;
    
    // Lock account after MAX_PIN_ATTEMPTS
    if user_pin.failed_attempts >= MAX_PIN_ATTEMPTS {
        user_pin.locked_until = Some(now + PIN_LOCKOUT_DURATION);
    }
    
    state.user_pins.insert(user_id.clone(), user_pin.clone());
    
    // Log audit using shared library
    audit::log_failure(
        "pin_attempt_failed",
        Some(user_id),
        format!("Failed PIN attempt #{}", user_pin.failed_attempts)
    );
    
    Ok(())
}
